{"uid":"8edbb1792b93cd93","name":"test_user_play_the_cd[remote, play-アナと雪の女王 ザ・ソングス 日本語版]","fullName":"tests.steps.test_00_listen_to_a_CD#test_user_switches_tracks_during_playback","historyId":"c2b5f38d704aba979b2eeb91405a3963","time":{"start":1768551479132,"stop":1768551687703,"duration":208571},"description":"/Users/lily/PycharmProjects/pytest-bdd-project/amp/tests/features/00_listen_to_a_CD.feature: user_switches_tracks_during_playback","descriptionHtml":"<p>/Users/lily/PycharmProjects/pytest-bdd-project/amp/tests/features/00_listen_to_a_CD.feature: user_switches_tracks_during_playback</p>\n","status":"broken","statusMessage":"selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\nStacktrace:\nUnknownError: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\n    at getResponseForW3CError (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/errors.js:1145:9)\n    at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)","statusTrace":"self = <appium.webdriver.webdriver.WebDriver (session=\"cc8a51ce-d449-40ed-89f1-c76441809a58\")>, content_type = 'plaintext'\n\n    def get_clipboard(self, content_type: str = ClipboardContentType.PLAINTEXT) -> bytes:\n        \"\"\"Receives the content of the system clipboard\n    \n        Args:\n            content_type: One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT\n                is supported on Android\n    \n        Returns:\n            Clipboard content as bytearray. Or empty bytes if the clipboard is empty\n        \"\"\"\n        ext_name = 'mobile: getClipboard'\n        options = {'contentType': content_type}\n        try:\n>           base64_str = self.assert_extension_exists(ext_name).execute_script(ext_name, options)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/extensions/clipboard.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <appium.webdriver.webdriver.WebDriver (session=\"cc8a51ce-d449-40ed-89f1-c76441809a58\")>, ext_name = 'mobile: getClipboard'\n\n    def assert_extension_exists(self, ext_name: str) -> Self:\n        \"\"\"\n        Verifies if the given extension is not present in the list of absent extensions\n        for the given driver instance.\n        This API is designed for private usage.\n    \n        :param ext_name: extension name\n        :return: self instance for chaining\n        :raise UnknownMethodException: If the extension has been marked as absent once\n        \"\"\"\n        if ext_name in self._absent_extensions:\n>           raise UnknownMethodException()\nE           selenium.common.exceptions.UnknownMethodException: Message: None\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/webdriver.py:417: UnknownMethodException\n\nDuring handling of the above exception, another exception occurred:\n\nfixturefunc = <function should_see_the_track_playing at 0x114d2e5c0>\nrequest = <FixtureRequest for <Function test_user_switches_tracks_during_playback[remote, play-\\u30a2\\u30ca\\u3068\\u96ea\\u306e\\u5973\\u738b \\u30b6\\u30fb\\u30bd\\u30f3\\u30b0\\u30b9 \\u65e5\\u672c\\u8a9e\\u7248-remote, next-01]>>\nkwargs = {'driver': <appium.webdriver.webdriver.WebDriver (session=\"cc8a51ce-d449-40ed-89f1-c76441809a58\")>, 'track': '01'}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if is_generator(fixturefunc):\n            fixturefunc = cast(\n                Callable[..., Generator[FixtureValue, None, None]], fixturefunc\n            )\n            generator = fixturefunc(**kwargs)\n            try:\n                fixture_result = next(generator)\n            except StopIteration:\n                raise ValueError(f\"{request.fixturename} did not yield a value\") from None\n            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)\n            request.addfinalizer(finalizer)\n        else:\n            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)\n>           fixture_result = fixturefunc(**kwargs)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:898: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/steps/test_00_listen_to_a_CD.py:114: in should_see_the_track_playing\n    rs = p_home.update_playback_status()\npages/home_page.py:21: in update_playback_status\n    return self.extract_text()\npages/robot.py:197: in extract_text\n    extracted_text = self.driver.get_clipboard_text()\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/extensions/clipboard.py:95: in get_clipboard_text\n    return self.get_clipboard(ClipboardContentType.PLAINTEXT).decode('UTF-8')\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/extensions/clipboard.py:86: in get_clipboard\n    base64_str = self.mark_extension_absence(ext_name).execute(Command.GET_CLIPBOARD, options)['value']\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:429: in execute\n    self.error_handler.check_response(response)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <appium.webdriver.errorhandler.MobileErrorHandler object at 0x1143f91c0>\nresponse = {'status': 500, 'value': '{\"value\":{\"error\":\"unknown error\",\"message\":\"An unknown server-side error occurred while pro...asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)\"}}'}\n\n    def check_response(self, response: Dict[str, Any]) -> None:\n        \"\"\"\n        https://www.w3.org/TR/webdriver/#errors\n        \"\"\"\n        payload = response.get('value', '')\n        if isinstance(payload, dict):\n            payload_dict = payload\n        else:\n            try:\n                payload_dict = json.loads(payload)\n            except (json.JSONDecodeError, TypeError):\n                return\n            if not isinstance(payload_dict, dict):\n                return\n        value = payload_dict.get('value')\n        if not isinstance(value, dict):\n            return\n        error = value.get('error')\n        if not error:\n            return\n    \n        message = value.get('message', error)\n        stacktrace = value.get('stacktrace', '')\n        # In theory, we should also be checking HTTP status codes.\n        # Java client, for example, prints a warning if the actual `error`\n        # value does not match to the response's HTTP status code.\n        exception_class: Type[sel_exceptions.WebDriverException] = ERROR_TO_EXC_MAPPING.get(\n            error, sel_exceptions.WebDriverException\n        )\n        if exception_class is sel_exceptions.WebDriverException and message:\n            if message == 'No such context found.':\n                exception_class = appium_exceptions.NoSuchContextException\n            elif message == 'That command could not be executed in the current context.':\n                exception_class = appium_exceptions.InvalidSwitchToTargetException\n    \n        if exception_class is sel_exceptions.UnexpectedAlertPresentException:\n            raise sel_exceptions.UnexpectedAlertPresentException(\n                msg=message,\n                stacktrace=format_stacktrace(stacktrace),\n                alert_text=value.get('data'),\n            )\n>       raise exception_class(msg=message, stacktrace=format_stacktrace(stacktrace))\nE       selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\nE       Stacktrace:\nE       UnknownError: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\nE           at getResponseForW3CError (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/errors.js:1145:9)\nE           at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/errorhandler.py:125: WebDriverException","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"driver","time":{"start":1768551479133,"stop":1768551484670,"duration":5537},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false}],"testStage":{"description":"/Users/lily/PycharmProjects/pytest-bdd-project/amp/tests/features/00_listen_to_a_CD.feature: user_switches_tracks_during_playback","status":"broken","statusMessage":"selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\nStacktrace:\nUnknownError: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\n    at getResponseForW3CError (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/errors.js:1145:9)\n    at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)","statusTrace":"self = <appium.webdriver.webdriver.WebDriver (session=\"cc8a51ce-d449-40ed-89f1-c76441809a58\")>, content_type = 'plaintext'\n\n    def get_clipboard(self, content_type: str = ClipboardContentType.PLAINTEXT) -> bytes:\n        \"\"\"Receives the content of the system clipboard\n    \n        Args:\n            content_type: One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT\n                is supported on Android\n    \n        Returns:\n            Clipboard content as bytearray. Or empty bytes if the clipboard is empty\n        \"\"\"\n        ext_name = 'mobile: getClipboard'\n        options = {'contentType': content_type}\n        try:\n>           base64_str = self.assert_extension_exists(ext_name).execute_script(ext_name, options)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/extensions/clipboard.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <appium.webdriver.webdriver.WebDriver (session=\"cc8a51ce-d449-40ed-89f1-c76441809a58\")>, ext_name = 'mobile: getClipboard'\n\n    def assert_extension_exists(self, ext_name: str) -> Self:\n        \"\"\"\n        Verifies if the given extension is not present in the list of absent extensions\n        for the given driver instance.\n        This API is designed for private usage.\n    \n        :param ext_name: extension name\n        :return: self instance for chaining\n        :raise UnknownMethodException: If the extension has been marked as absent once\n        \"\"\"\n        if ext_name in self._absent_extensions:\n>           raise UnknownMethodException()\nE           selenium.common.exceptions.UnknownMethodException: Message: None\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/webdriver.py:417: UnknownMethodException\n\nDuring handling of the above exception, another exception occurred:\n\nfixturefunc = <function should_see_the_track_playing at 0x114d2e5c0>\nrequest = <FixtureRequest for <Function test_user_switches_tracks_during_playback[remote, play-\\u30a2\\u30ca\\u3068\\u96ea\\u306e\\u5973\\u738b \\u30b6\\u30fb\\u30bd\\u30f3\\u30b0\\u30b9 \\u65e5\\u672c\\u8a9e\\u7248-remote, next-01]>>\nkwargs = {'driver': <appium.webdriver.webdriver.WebDriver (session=\"cc8a51ce-d449-40ed-89f1-c76441809a58\")>, 'track': '01'}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if is_generator(fixturefunc):\n            fixturefunc = cast(\n                Callable[..., Generator[FixtureValue, None, None]], fixturefunc\n            )\n            generator = fixturefunc(**kwargs)\n            try:\n                fixture_result = next(generator)\n            except StopIteration:\n                raise ValueError(f\"{request.fixturename} did not yield a value\") from None\n            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)\n            request.addfinalizer(finalizer)\n        else:\n            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)\n>           fixture_result = fixturefunc(**kwargs)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:898: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/steps/test_00_listen_to_a_CD.py:114: in should_see_the_track_playing\n    rs = p_home.update_playback_status()\npages/home_page.py:21: in update_playback_status\n    return self.extract_text()\npages/robot.py:197: in extract_text\n    extracted_text = self.driver.get_clipboard_text()\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/extensions/clipboard.py:95: in get_clipboard_text\n    return self.get_clipboard(ClipboardContentType.PLAINTEXT).decode('UTF-8')\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/extensions/clipboard.py:86: in get_clipboard\n    base64_str = self.mark_extension_absence(ext_name).execute(Command.GET_CLIPBOARD, options)['value']\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:429: in execute\n    self.error_handler.check_response(response)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <appium.webdriver.errorhandler.MobileErrorHandler object at 0x1143f91c0>\nresponse = {'status': 500, 'value': '{\"value\":{\"error\":\"unknown error\",\"message\":\"An unknown server-side error occurred while pro...asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)\"}}'}\n\n    def check_response(self, response: Dict[str, Any]) -> None:\n        \"\"\"\n        https://www.w3.org/TR/webdriver/#errors\n        \"\"\"\n        payload = response.get('value', '')\n        if isinstance(payload, dict):\n            payload_dict = payload\n        else:\n            try:\n                payload_dict = json.loads(payload)\n            except (json.JSONDecodeError, TypeError):\n                return\n            if not isinstance(payload_dict, dict):\n                return\n        value = payload_dict.get('value')\n        if not isinstance(value, dict):\n            return\n        error = value.get('error')\n        if not error:\n            return\n    \n        message = value.get('message', error)\n        stacktrace = value.get('stacktrace', '')\n        # In theory, we should also be checking HTTP status codes.\n        # Java client, for example, prints a warning if the actual `error`\n        # value does not match to the response's HTTP status code.\n        exception_class: Type[sel_exceptions.WebDriverException] = ERROR_TO_EXC_MAPPING.get(\n            error, sel_exceptions.WebDriverException\n        )\n        if exception_class is sel_exceptions.WebDriverException and message:\n            if message == 'No such context found.':\n                exception_class = appium_exceptions.NoSuchContextException\n            elif message == 'That command could not be executed in the current context.':\n                exception_class = appium_exceptions.InvalidSwitchToTargetException\n    \n        if exception_class is sel_exceptions.UnexpectedAlertPresentException:\n            raise sel_exceptions.UnexpectedAlertPresentException(\n                msg=message,\n                stacktrace=format_stacktrace(stacktrace),\n                alert_text=value.get('data'),\n            )\n>       raise exception_class(msg=message, stacktrace=format_stacktrace(stacktrace))\nE       selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\nE       Stacktrace:\nE       UnknownError: An unknown server-side error occurred while processing the command. Original error: Cannot retrieve the current clipboard content from the device. Make sure the Appium Settings application is up to date. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell ime enable io.appium.settings/.AppiumIME' timed out after 20000ms'. Try to increase the 20000ms adb execution timeout represented by 'adbExecTimeout' capability\nE           at getResponseForW3CError (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/errors.js:1145:9)\nE           at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/errorhandler.py:125: WebDriverException","steps":[],"attachments":[{"uid":"52f48e8047ff7d13","name":"10e78425-0162-4e35-b69a-25955ba6058d-attachment.attach","source":"52f48e8047ff7d13.attach","type":"text/plain","size":114},{"uid":"5adce6199172a32a","name":"stdout","source":"5adce6199172a32a.txt","type":"text/plain","size":43}],"parameters":[],"stepsCount":0,"attachmentsCount":2,"shouldDisplayMessage":true,"hasContent":true},"afterStages":[{"name":"driver::0","time":{"start":1768551687861,"stop":1768551688816,"duration":955},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false}],"labels":[{"name":"parentSuite","value":"tests.steps"},{"name":"suite","value":"test_00_listen_to_a_CD"},{"name":"host","value":"macdeMacBook-Pro.local"},{"name":"thread","value":"15764-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.steps.test_00_listen_to_a_CD"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"_pytest_bdd_example","value":"{'plays': 'remote, play', 'disc': 'アナと雪の女王 ザ・ソングス 日本語版', 'switches': 'remote, next', 'track': '01'}"}],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"8edbb1792b93cd93.json","parameterValues":["{'plays': 'remote, play', 'disc': 'アナと雪の女王 ザ・ソングス 日本語版', 'switches': 'remote, next', 'track': '01'}"]}