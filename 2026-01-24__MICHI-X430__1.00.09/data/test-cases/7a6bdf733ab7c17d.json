{"uid":"7a6bdf733ab7c17d","name":"test_user_switch_tracks_during_playback[PCM->PCM(Mac)-remote, next-PCM]","fullName":"tests.steps.test_00_play_via_pcusb_input#test_user_switch_tracks_during_playback","historyId":"a8d1c2c536da63b6a9c633e99be98ec2","time":{"start":1769130885842,"stop":1769130886040,"duration":198},"description":"/Users/lily/PycharmProjects/pytest-bdd-project/amp/tests/features/00_play_via_pcusb_input.feature: user_switch_tracks_during_playback","descriptionHtml":"<p>/Users/lily/PycharmProjects/pytest-bdd-project/amp/tests/features/00_play_via_pcusb_input.feature: user_switch_tracks_during_playback</p>\n","status":"broken","statusMessage":"selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Error getting device API level. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell getprop ro.build.version.sdk' exited with code 1'; Command output: adb: device still authorizing\n\nStacktrace:\nUnknownError: An unknown server-side error occurred while processing the command. Original error: Error getting device API level. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell getprop ro.build.version.sdk' exited with code 1'; Command output: adb: device still authorizing\n\n    at getResponseForW3CError (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/errors.js:1145:9)\n    at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)","statusTrace":"self = <FixtureRequest for <Function test_user_switch_tracks_during_playback[PCM->PCM(Mac)-remote, next-PCM]>>, argname = 'driver'\n\n    def getfixturevalue(self, argname: str) -> Any:\n        \"\"\"Dynamically run a named fixture function.\n    \n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n    \n        This method can be used during the test setup phase or the test run\n        phase, but during the test teardown phase a fixture's value may not\n        be available.\n    \n        :param argname:\n            The fixture name.\n        :raises pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        # Note that in addition to the use case described in the docstring,\n        # getfixturevalue() is also called by pytest itself during item and fixture\n        # setup to evaluate the fixtures that are requested statically\n        # (using function parameters, autouse, etc).\n    \n>       fixturedef = self._get_active_fixturedef(argname)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:532: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:617: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:1091: in execute\n    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/pluggy/_hooks.py:513: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:1140: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/_pytest/fixtures.py:891: in call_fixture_func\n    fixture_result = next(generator)\nconftest.py:37: in driver\n    driver = webdriver.Remote(command_executor=\"http://localhost:4723\",\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/webdriver.py:227: in __init__\n    super().__init__(\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:250: in __init__\n    self.start_session(capabilities)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/appium/webdriver/webdriver.py:319: in start_session\n    response = self.execute(RemoteCommand.NEW_SESSION, w3c_caps)\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/selenium/webdriver/remote/webdriver.py:429: in execute\n    self.error_handler.check_response(response)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x10b852b70>\nresponse = {'status': 500, 'value': '{\"value\":{\"error\":\"unknown error\",\"message\":\"An unknown server-side error occurred while pro...asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)\"}}'}\n\n    def check_response(self, response: Dict[str, Any]) -> None:\n        \"\"\"Checks that a JSON response from the WebDriver does not have an\n        error.\n    \n        :Args:\n         - response - The JSON response from the WebDriver server as a dictionary\n           object.\n    \n        :Raises: If the response contains an error message.\n        \"\"\"\n        status = response.get(\"status\", None)\n        if not status or status == ErrorCode.SUCCESS:\n            return\n        value = None\n        message = response.get(\"message\", \"\")\n        screen: str = response.get(\"screen\", \"\")\n        stacktrace = None\n        if isinstance(status, int):\n            value_json = response.get(\"value\", None)\n            if value_json and isinstance(value_json, str):\n                import json\n    \n                try:\n                    value = json.loads(value_json)\n                    if len(value) == 1:\n                        value = value[\"value\"]\n                    status = value.get(\"error\", None)\n                    if not status:\n                        status = value.get(\"status\", ErrorCode.UNKNOWN_ERROR)\n                        message = value.get(\"value\") or value.get(\"message\")\n                        if not isinstance(message, str):\n                            value = message\n                            message = message.get(\"message\")\n                    else:\n                        message = value.get(\"message\", None)\n                except ValueError:\n                    pass\n    \n        exception_class: Type[WebDriverException]\n        e = ErrorCode()\n        error_codes = [item for item in dir(e) if not item.startswith(\"__\")]\n        for error_code in error_codes:\n            error_info = getattr(ErrorCode, error_code)\n            if isinstance(error_info, list) and status in error_info:\n                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)\n                break\n        else:\n            exception_class = WebDriverException\n    \n        if not value:\n            value = response[\"value\"]\n        if isinstance(value, str):\n            raise exception_class(value)\n        if message == \"\" and \"message\" in value:\n            message = value[\"message\"]\n    \n        screen = None  # type: ignore[assignment]\n        if \"screen\" in value:\n            screen = value[\"screen\"]\n    \n        stacktrace = None\n        st_value = value.get(\"stackTrace\") or value.get(\"stacktrace\")\n        if st_value:\n            if isinstance(st_value, str):\n                stacktrace = st_value.split(\"\\n\")\n            else:\n                stacktrace = []\n                try:\n                    for frame in st_value:\n                        line = frame.get(\"lineNumber\", \"\")\n                        file = frame.get(\"fileName\", \"<anonymous>\")\n                        if line:\n                            file = f\"{file}:{line}\"\n                        meth = frame.get(\"methodName\", \"<anonymous>\")\n                        if \"className\" in frame:\n                            meth = f\"{frame['className']}.{meth}\"\n                        msg = \"    at %s (%s)\"\n                        msg = msg % (meth, file)\n                        stacktrace.append(msg)\n                except TypeError:\n                    pass\n        if exception_class == UnexpectedAlertPresentException:\n            alert_text = None\n            if \"data\" in value:\n                alert_text = value[\"data\"].get(\"text\")\n            elif \"alert\" in value:\n                alert_text = value[\"alert\"].get(\"text\")\n            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here\n>       raise exception_class(message, screen, stacktrace)\nE       selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Error getting device API level. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell getprop ro.build.version.sdk' exited with code 1'; Command output: adb: device still authorizing\nE       \nE       Stacktrace:\nE       UnknownError: An unknown server-side error occurred while processing the command. Original error: Error getting device API level. Original error: Error executing adbExec. Original error: 'Command '/Users/lily/Library/android_sdk/platform-tools/adb -P 5037 -s 192.168.0.75\\:5556 shell getprop ro.build.version.sdk' exited with code 1'; Command output: adb: device still authorizing\nE       \nE           at getResponseForW3CError (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/errors.js:1145:9)\nE           at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/@appium/base-driver/lib/protocol/protocol.js:491:57)\n\n../../../Documents/pytest-bdd-example-master/.venv/lib/python3.12/site-packages/selenium/webdriver/remote/errorhandler.py:232: WebDriverException","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"afterStages":[],"labels":[{"name":"parentSuite","value":"tests.steps"},{"name":"suite","value":"test_00_play_via_pcusb_input"},{"name":"host","value":"macdeMacBook-Pro.local"},{"name":"thread","value":"37559-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.steps.test_00_play_via_pcusb_input"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"_pytest_bdd_example","value":"{'playback': 'PCM->PCM(Mac)', 'switches': 'remote, next', 'track': 'PCM'}"}],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"7a6bdf733ab7c17d.json","parameterValues":["{'playback': 'PCM->PCM(Mac)', 'switches': 'remote, next', 'track': 'PCM'}"]}